function plot(self)
%  function plot( coupe, cle , liste_profils, varargin )
%    Clabel)
% plot
% Appelé par select_section
%
% $Id: plot.m 120 2007-02-02 13:42:20Z jgrelet $

%% root et cle
cle = self.cle;
root = get(0, 'UserData');
profil = root.self;
cles = keys(data_2d(profil));
r = roscop(profil);
vr = get(r,cle);
coupe = self.code_roscop;
liste_profils = self.liste_profils;
%% Définie les valeurs par défault de la section lors du premier tracé.

PopupMin_Value = self.popup_contour_min;
PopupMax_Value = self.popup_contour_max;


if self.contour_min == 1
  self.contour_min=vr.min;
end

if self.contour_max == 1
  self.contour_max=vr.max;
end

%% Recupère la clé en cours.
for i=1:length( cles )
  if get(findobj('Tag',['radio_' cles{i}]),'Value')
    cle = cles{i};
    break
  end
end

%% initialisation des variables
  
%vary recupère les valeurs des profondeurs afin d'en extraire la valeur
%max (profondeur_max) pour l'ajouter au popup PRES_max avec cette même
%valeur -100 et -200. 
%###### a reprendre correctement, pas le temps, dans l'avion Mahe/Paris,
	% plus batterie !!! verifier avec cvs diff si c'est Nico ou moi qui ecrit
	% ces anneries ....
pmax_lbl=[];
vary = get(data_2d(profil),'PRES');
  if isempty(vary)
    vary = get(data_2d(profil),'DEPH');
	end
	 if isempty(vary)
    vary = get(data_2d(profil),'HEIG');
	end

profondeur_max= approx(max(vary(~isnan(vary))),3);
%La fonction unique evite les redondances des pmax_lbl mais laisse en
%desordre les différentes valeurs.
pmax_lbl = unique([self.pmax_lbl, num2str(profondeur_max-200),...
           num2str(profondeur_max-100), num2str(profondeur_max)]);
%on convertie alors les cells en chiffre...
a=[];
for i=1:length(pmax_lbl)
  a=[a,' ',cell2mat(pmax_lbl(i))];
end
%on remet ces valeurs dans l'ordre : fonction sort
a = sort(str2num(a));
%on les reconverties en cells
b={};
for i=1:length(a)
b(i)={num2str(a(i))};
end 
%et on remplace les anciennes valeurs désordonnées par les nouvelles.
pmax_lbl=b;  


pmax = str2num(pmax_lbl{self.pmax_value});
pmin = str2num(self.pmin_lbl{self.pmin_value});
pas  = str2num(self.pas_lbl{self.pas_value});
pas_interpol = str2num(self.pas_interpol_lbl{self.pas_interpol_value});
interpolation = str2num(self.interpolation_lbl{self.interpolation_value});
sub_plot = str2num(self.sub_plot_lbl{self.sub_plot_value});
methode = self.methode;
label = self.geo;
Clabel = self.Clabel;
ProfilSpec = self.ProfilSpec;

if ~exist('filename') %%%%%%%%%% Voir si conservé ou non ??
  filename = '';
  printer = '';
end

if isempty(sub_plot)
  sub_plot=0;
end

% Recuperation du titre de la fenêtre.
switch self.titre
  case 0
    titre = '';
  case 1
    titre = {[get( get( profil, 'data_0d'), 'CYCLE_MESURE') ...
      'Profils: ' num2str(min(self.liste_profils)) ' - '...
      num2str(max(self.liste_profils))];...
      [cle ': ' vr.description  ' (' vr.unit ')'] };
end


% si la figure plot existe, recupere sont handle
hdl = findobj('Tag', 'plot');

%% Affichage de la fenêtre de section.
% Si cette fenêtre n'existe pas.
if isempty(hdl)
  hdl = figure( ...
    'Position', centerfig(800, 700), ...
    'Color', get(0,'DefaultUIControlBackgroundColor'),...
    'name','Section Océano',...
    'HandleVisibility','callback',...
    'resize','off',...
    'MenuBar','figure',...
    'tag', 'plot' );
  popup_min=[];
  popup_max=[];
  RadioNumStation=[];
  %Clabel=[];
  figureInside(self);

  % Si la figure existe déjà.
else
  clf(hdl);
  figure(hdl);
  figureInside(self);
end

%% Mise en place des Uipanels et uicontrols.
  function figureInside(self)

    root = get(0,'userdata');
    s = get(r,cle);
    string_min = cons_string_min_popup(vr.scale);
    string_max = cons_string_max_popup(vr.scale);
    F = findobj('Tag','F_Tag');
    popup_min = PopupMin_Value;
    popup_max = PopupMax_Value;
      


    %% trace le panel des paramêtres plot_section
    % hdl_plot: le panel contenant la coupe
    hdl_plot = uipanel('parent',hdl,'FontSize',8,...
      'Position',[0 0 .80 1]); % [gauche hauteur droite bas]
    set(hdl_plot,'Tag','Tag_hdl_plot');

    % hdl_action: le panel de droite contenant les controls de choix du
    % contour, etc
    hdl_action = uipanel('parent',hdl,'FontSize',8,...
      'Position',[.8 0 .2 1]);

    %String de Minimum 'Pres'(pression) pour modification de l'axe des ordonnées.
    uicontrol('parent',hdl_action,...
      'Style','text',...
      'Units','normalized',...
      'Position',[.15 .94 .75 .05],...
      'String','PRES_min',...
      'HorizontalAlignment','left');

    %Popup menu de la pression.
    ui_select_one = uicontrol('parent',hdl_action,...
      'Units','normalized',...
      'Position',[.15 .92 .75 .05],...
      'Style','popupmenu',...
      'fontname','serif',...
      'fontsize',7,...
      'Tag','select_pmin',...
      'String', self.pmin_lbl ,...
      'Value', self.pmin_value ,...
      'BackgroundColor','w',...
      'Callback',@select_pmin_callback);

    %String de Maximum 'Pres'(pression) pour modification de l'axe des ordonnées.
    uicontrol('parent',hdl_action,...
      'Style','text',...
      'Units','normalized',...
      'Position',[.15 .88 .75 .05],...
      'String','PRES_max',...
      'HorizontalAlignment','left');

    %Popup menu de la pression.
    ui_select_one = uicontrol('parent',hdl_action,...
      'Units','normalized',...
      'Position',[.15 .86 .75 .05],...
      'Style','popupmenu',...
      'fontsize',7,...
      'Tag','select_pmax',...
      'String', pmax_lbl ,...
      'Value', self.pmax_value ,...
      'BackgroundColor','w',...
      'Callback',@select_pmax_callback);

    %String de Maximum 'Pres'(pression) pour modification de l'axe des ordonnées.
    uicontrol('parent',hdl_action,...
      'Style','text',...
      'Units','normalized',...
      'Position',[.15 .82 .75 .05],...
      'String','PRES_coupure',...
      'HorizontalAlignment','left');

    %Popup menu de la pression.
    ui_select_one = uicontrol('parent',hdl_action,...
      'Units','normalized',...
      'Position',[.15 .80 .75 .05],...
      'Style','popupmenu',...
      'fontsize',7,...
      'Tag','sub_plot_tag',...
      'String', self.sub_plot_lbl,...
      'Value', self.sub_plot_value,...
      'BackgroundColor','w',...
      'Callback',@select_sub_plot_callback);

    %Uipanel des paramêtres du contourage.
    hdl_type_contour = uipanel('parent',hdl_action,...
      'Title','Type de Contour',...
      'tag','parametres',...
      'FontSize',8,...
      'Units','pixels',...
      'Position',[6 390 145 155]);

    %Titre Méthode de contourage
    uicontrol('parent',hdl_type_contour,...
      'Style','text',...
      'Units','normalized',...
      'Position',[.10 .90 .75 .08],...
      'String','Contourage',...
      'HorizontalAlignment','left');

    %Popupmenu Méthode de contourage
    ui_action_one = uicontrol('parent',hdl_type_contour,...
      'Units','normalized',...
      'Position',[.10 .82 .75 .05],...
      'Style','popupmenu',...
      'fontsize',7,...
      'String','contourf | pcolor | contour3D',...
      'Tag','select_methode',...
      'Value',self.methode_value,...
      'BackgroundColor','w',...
      'CallBack',@select_methode_callback);

    %Titre Pas d'interpolation du contourage
    uicontrol('parent',hdl_type_contour,...
      'Style','text',...
      'Units','normalized',...
      'Position',[.10 .60 .75 .08],...
      'String','Interpolation',...
      'HorizontalAlignment','left');

    %Popupmenu du pas d'interpolation du contourage
    ui_action_one = uicontrol('parent',hdl_type_contour,...
      'Units','normalized',...
      'Position',[.10 .52 .75 .05],...
      'Style','popupmenu',...
      'fontsize',7,...
      'String',self.interpolation_lbl,...
      'Tag','select_interpolation',...
      'Value',self.interpolation_value,...
      'BackgroundColor','w',...
      'CallBack',@select_interpolation_callback);

    %String de 'Pas'(pas de contourage) pour modification du contourage.
    uicontrol('parent',hdl_type_contour,...
      'Style','text',...
      'Units','normalized',...
      'Position',[.10 .28 .75 .08],...
      'String','Pas Cont. Gras',...
      'HorizontalAlignment','left');

    %Popup menu du pas de contourage.
    ui_select_one = uicontrol('parent',hdl_type_contour,...
      'Units','normalized',...
      'Position',[.10 .18 .75 .08],...
      'Style','popupmenu',...
      'fontsize',7,...
      'Tag','select_pas',...
      'String',self.pas_lbl,...
      'value',self.pas_value,...
      'BackgroundColor','w',...
      'Callback',@select_pas_callbak);

    %Uipanel contenant paramètre de coloration de la section
    hdl_contour = uipanel('parent',hdl_action,...
      'Title','Contourage',...
      'tag','parametres',...
      'FontSize',8,...
      'Units','pixels',...
      'Position',[6 220 145 160]);

    %String de 'Min_contour' pour modification de l'interpolation.
    uicontrol('parent',hdl_contour,...
      'Style','text',...
      'Units','normalized',...
      'Position',[.10 .92 .75 .08],...
      'String','Min_contour',...
      'HorizontalAlignment','left');

    %Popup menu du min d'interpolation.
    ui_select_one = uicontrol('parent',hdl_contour,...
      'Units','normalized',...
      'Position',[.10 .84 .75 .05],...
      'Style','popupmenu',...
      'fontsize',7,...
      'Tag',['popupmenu_sect_min' cle],...
      'String',string_min,...
      'value',self.popup_contour_min,...
      'BackgroundColor','w');

    %String de 'Max_contour' pour modification de l'interpolation.
    uicontrol('parent',hdl_contour,...
      'Style','text',...
      'Units','normalized',...
      'Position',[.10 .64 .75 .08],...
      'String','Max_contour',...
      'HorizontalAlignment','left');

    %Popup menu du max d'interpolation.
    ui_select_one = uicontrol('parent',hdl_contour,...
      'Units','normalized',...
      'Position',[.10 .58 .75 .05],...
      'fontsize',7,...
      'Style','popupmenu',...
      'Tag',['popupmenu_sect_max' cle],...
      'String',string_max,...
      'value',popup_max,...
      'BackgroundColor','w');

    %Titre du popup menu Pas de contourage.
    uicontrol('parent',hdl_contour,...
      'Style','text',...
      'Units','normalized',...
      'Position',[.10 .35 .75 .08],...
      'String','Pas_contour',...
      'HorizontalAlignment','left');

    %Popup menu Pas de contourage.
    ui_select_one = uicontrol('parent',hdl_contour,...
      'Units','normalized',...
      'Position',[.10 .29 .75 .03],...
      'Style','popupmenu',...
      'fontsize',7,...
      'Tag','select_pas_interpol',...
      'String',self.pas_interpol_lbl,...
      'value',self.pas_interpol_value,...
      'BackgroundColor','w');
    %'Callback',@select_pas_interpol_callbak);

    uicontrol('parent',hdl_contour,...
      'Style','pushbutton',...
      'Position',[10 2 120 20],...
      'String','Valider',...
      'Interruptible','on',...
      'Tag','valid_Tag',...
      'Callback', {@valid_contourage_callback,cle});

    uicontrol('parent',hdl_action,...
      'Style','text',...
      'Units','normalized',...
      'Position',[.15 .22 .75 .06],...
      'String','Clabels',...
      'HorizontalAlignment','left');

    ui_action_one = uicontrol('parent',hdl_action,...
      'Units','normalized',...
      'Position',[.15 .20 .75 .04],...
      'Style','popupmenu',...
      'fontsize',7,...
      'Tag','Clabel_Tag',...
      'String','Auto|Manual|None',...
      'Value',self.Clabel_value,...
      'BackgroundColor','w',...
      'Callback',@affiche_Clabel_callback);

    ui_action_one = uicontrol('parent',hdl_action,...
      'Units','normalized',...
      'Position',[.15 .17 .75 .04],...
      'Style','radio',...
      'Tag','geo_Tag',...
      'String','TickGEO',...
      'Value',self.geo_value,...
      'BackgroundColor',get(0,'DefaultUIControlBackgroundColor'),...
      'Callback',@geo_callback);

    ui_action_one = uicontrol('parent',hdl_action,...
      'Units','normalized',...
      'Position',[.15 .15 .75 .03],...
      'Style','radio',...
      'Tag','NStation_Tag',...
      'String','Titre',...
      'Value',self.titre,...
      'BackgroundColor',get(0,'DefaultUIControlBackgroundColor'),...
      'Callback',@affiche_numero_station_callback);

    ui_action_one = uicontrol('parent',hdl_action,...
      'Units','normalized',...
      'Position',[.15 .13 .45 .02],...
      'Style','radio',...
      'Tag','ProfilSpec_tag',...
      'String','Stations',...
      'Value',self.ProfilSpec_value,...
      'BackgroundColor',get(0,'DefaultUIControlBackgroundColor'),...
      'Callback',@ProfilSpec_callback);

    uicontrol('parent',hdl_action,...
      'Style','pushbutton',...
      'Position',[15 20 126 20],...
      'String','Enreg/Imprim',...
      'Interruptible','on',...
      'Tag','enregim_Tag',...
      'Callback', {@enregim_callback, self});
    aconstruire(self);
  end

%% Appel à la fonction plot_section qui va tracer la section dans une nouvelle fenêtre.

  function aconstruire(self)
    % Modifie l'aspect de la sourie en sablié.
    set(gcf,'Pointer','watch');
    figure(hdl);
    hdl_plot = uipanel('parent',hdl,'FontSize',8,...
      'Position',[0 0 .80 1]);
    if sub_plot == 0
      F = plot_section(coupe, cle,'profils',liste_profils,...
        'methode', methode, 'vertical',[pmin pmax],'Pas',pas,...
        'contour',[self.contour_min:pas_interpol:self.contour_max],...
        'ClabelSpec',Clabel,'interpol',interpolation,'titre', titre,...
        'label', label, 'profilspec', ProfilSpec, 'Print', {printer, filename});
    else
      F = plot_section(coupe, cle,'profils',liste_profils,...
        'methode', methode, 'vertical',[pmin sub_plot;sub_plot pmax],'Pas',pas,...
        'contour',[self.contour_min:pas_interpol:self.contour_max],...
        'ClabelSpec',Clabel,'interpol',interpolation,'titre', titre,...
        'label', label, 'profilspec', ProfilSpec,'Print', {printer, filename});
    end
    % Recupère l'ensemble des éléments de la fenêtre générée par
    % plot_section
    set(get(F,'children'),'parent',hdl_plot);
    root = get(0, 'UserData');
    % Ferme la fenêtre maintenant vide du plot_section.
    close(F);
    if isempty(pas)
      pas = 0;
    end
    % Script affichant la ligne de code générant une section dans une
    % nouvelle fenêtre avec les paramètres selectionnés par l'utilisateur.
    if sub_plot == 0
      str = sprintf(['''%s'',''%s'',''profils'',[%s],''methode'',''contourf''' ...
        ',''Interpol'',10,''vertical'',[%s %s],''Contour'',[%s:%s:%s]',...
        ',''Pas'',%s,''ProfilSpec'',''%s'',''ClabelSpec'',''%s'''],...
        coupe, cle, num2str(liste_profils), num2str(pmin), num2str(pmax),...
        num2str(self.contour_min),num2str(pas_interpol),num2str(self.contour_max),...
        num2str(pas),ProfilSpec, Clabel );
      disp( ['plot_section(' str ');']);
    else
      str = sprintf(['''%s'',''%s'',''profils'',[%s],''methode'',''contourf''' ...
        ',''Interpol'',10,''vertical'',[%s %s;%s %s],''Contour'',[%s:%s:%s]',...
        ',''Pas'',%s,''ProfilSpec'',''%s'',''ClabelSpec'',''%s'''],...
        coupe, cle, num2str(liste_profils), num2str(pmin),...
        num2str(sub_plot),num2str(sub_plot), num2str(pmax),...
        num2str(self.contour_min),num2str(pas_interpol),num2str(self.contour_max),...
        num2str(pas),ProfilSpec, Clabel );
      disp( ['plot_section(' str ');']);
    end
    % Modifie l'aspect de la sourie en mode par défault.
    set(gcf,'Pointer','arrow');
  end



%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% %%%%%%%%%%%%%%%%%%%%%%%%   NESTED FUNCTIONS  %%%%%%%%%%%%%%%%%%%%%%%%%%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Evaluation du popup pmax de la section en cours.

  function select_pmax_callback(obj, eventdata)
    self.pmax_value = get(findobj('Tag','select_pmax'),'Value');
    plot(self);
  end

%% Evaluation du popup pmax de la section en cours.

  function select_pmin_callback(obj, eventdata)
    self.pmin_value = get(findobj('Tag','select_pmin'),'Value');
    plot(self);
  end

%% Callback du pop up menu générant une section scindée en 2 ou non.

  function select_sub_plot_callback(obj, eventdata)
    self.sub_plot_value = get(findobj('Tag','sub_plot_tag'),'value');
    plot(self);
  end

%% Callback de selection du pas d'interpolation.

  function select_interpolation_callback(obj, eventdata)
    self.interpolation_value = get(findobj('Tag','select_interpolation'),'Value');
    plot(self);
  end

%% Evaluation du popup Pas de la section en cours.

  function select_pas_callbak(obj, eventdata)
    self.pas_value=get(findobj('Tag','select_pas'),'Value');
    plot(self);
  end

%% Callback de l'affichage du titre de la section ou non.

  function affiche_numero_station_callback(obj, eventdata)
    self.titre = get(findobj('Tag','NStation_Tag'),'Value');
    if self.titre == 0
        set(get(findobj('Tag', 'Tag_section'),'title'),'string',' ');
    else
        set(get(findobj('Tag', 'Tag_section'),'title'),'string',titre);
        %plot(self);
    end
  end

%% Callback de l'affichage des labels de la section ou non.
  function affiche_Clabel_callback(obj, eventdata)
    self.Clabel_value = get(findobj('Tag','Clabel_Tag'),'Value');
    switch self.Clabel_value
      case 1
        self.Clabel = 'auto';
      case 2
        self.Clabel = 'manual';
      case 3
        self.Clabel = 'none';
    end
    plot(self);
  end

%% Callback du popup menu de selection du min et max de contourage.

  function valid_contourage_callback(obj, eventdata, cle)
    self.popup_contour_min = get(findobj('Tag',['popupmenu_sect_min' cle]),'Value');
    %switch PopupMin_Value
    switch self.popup_contour_min
      case 1
        self.contour_min = vr.min;
      otherwise
        self.contour_min = self.M_contour_min(self.popup_contour_min);
    end
    self.popup_contour_max = get(findobj('Tag',['popupmenu_sect_max' cle]),'Value');
    %switch PopupMax_Value
    switch self.popup_contour_max
      case 1
        self.contour_max = vr.max;
      otherwise
        self.contour_max = self.M_contour_max(self.popup_contour_max);
    end
    self.pas_interpol_value=get(findobj('Tag','select_pas_interpol'),'Value');
    plot(self);
  end

%% Callback recupérant les echelles min définies dans le fichier roscop.

  function s = cons_string_min_popup( scale )
    [ligne col]=size(scale);
    s = [];
    % la premiere ligne correspond au valeur auto
    s = 'Auto';
    %lit chacune des lignes de la structure scale.
    M_contour_min=zeros(ligne,1);
    for k=2:ligne
      rscale = scale(k-1,:);
      %convertit les valeurs lues et les transforme en string pour eviter
      %les problèmes d'affichage des nombres rééls dû à la fonction
      %sprintf.
      M_contour_min(k,1)=rscale(1);
      s = sprintf('%s|%s',s,num2str(rscale(1)));
    end
    self.M_contour_min = M_contour_min;
    clear ligne col k;
  end

%% Callback recupérant les echelles max définies dans le fichier roscop.

  function s = cons_string_max_popup( scale )
    [ligne col]=size(scale);
    s = [];
    % la premiere ligne correspond au valeur auto
    s = 'Auto';
    %lit chacune des lignes de la structure scale.
    M_contour_max=zeros(ligne,1);
    for k=2:ligne
      rscale = scale(k-1,:);
      %convertit les valeurs lues et les transforme en string pour eviter
      %les problèmes d'affichage des nombres rééls dû à la fonction
      %sprintf.
      M_contour_max(k,1)=rscale(2);
      s = sprintf('%s|%s',s,num2str(rscale(2)));
    end
    self.M_contour_max = M_contour_max;
    clear ligne col k;
  end

%% Callback de selection de la methode de contourage.

  function select_methode_callback(obj, eventdata)
    self.methode_value = get(findobj('Tag','select_methode'),'Value');
    switch self.methode_value
      case 1
        methode = 'contourf';
      case 2
        methode = 'pcolor';
      case 3
        methode = 'contour3D';
    end
    self.methode = methode;
    plot(self);
  end

%% Callback du type d'ordonnée désiré (TickGeo ou latitudes)

  function geo_callback(obj, eventdata)
    self.geo_value = get(findobj('Tag','geo_Tag'),'Value');
    switch self.geo_value
      case 0
        label = 'off';
      case 1
        label = 'on';
    end
    self.geo = label;
    plot(self);
  end

%% Callback d'affichage des numéros de stations.

  function ProfilSpec_callback(obj, eventdata)
    self.ProfilSpec_value = get(findobj('Tag','ProfilSpec_tag'),'Value');
    switch self.ProfilSpec_value
      case 0
        ProfilSpec = 'off'
      case 1
        ProfilSpec = 'on';
    end
    self.ProfilSpec = ProfilSpec;
    plot(self);
  end

%% Callback du boutons d'enregistrement, et impression de la section en cours.
  function enregim_callback (obj, eventdata, self)
    set(gcf,'Pointer','watch');
    if sub_plot == 0
      F = plot_section(coupe, cle,'profils',liste_profils,...
        'methode', methode, 'vertical',[pmin pmax],'Pas',pas,...
        'contour',[self.contour_min:pas_interpol:self.contour_max],...
        'ClabelSpec',Clabel,'interpol',interpolation,'titre', titre,...
        'label', label, 'profilspec', ProfilSpec);
    else
      F = plot_section(coupe, cle,'profils',liste_profils,...
        'methode', methode, 'vertical',[pmin sub_plot;sub_plot pmax],'Pas',pas,...
        'contour',[self.contour_min:pas_interpol:self.contour_max],...
        'ClabelSpec',Clabel,'interpol',interpolation,'titre', titre,...
        'label', label, 'profilspec', ProfilSpec);
    end
    set(gcf,'Pointer','arrow');
    button = questdlg('Que souhaitez vous faire ?','Enreg/Imprim','Enregistrer','Imprimer','Enregistrer');
    switch button
      case 'Enregistrer'
        [filenamext, pathname] = uiputfile( ...
          {'*.jpg';'*.epsc2';'*.*'}, ...
          'Save as');
        if  ~isempty(strfind(filenamext, 'jpg'))
          printer = 'jpeg';
        end
        if  ~isempty(strfind(filenamext, 'epsc2'))
          printer = 'epsc2';
        end
        filename='';
        str = filenamext;
        i=1;
        while isempty(strfind(str(i), '.'))
          filename=[filename str(i)];
          i=i+1;
        end
        filename=[pathname filename];
      case 'Imprimer'
        printdlg(F);
    end
    close(F);
    plot(self);
    set(gcf,'Pointer','arrow');
  end
end
